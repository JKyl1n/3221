/*
 * alarm_mutex.c
 *
 * This is an enhancement to the alarm_thread.c program, which
 * created an "alarm thread" for each alarm command. This new
 * version uses a single alarm thread, which reads the next
 * entry in a list. The main thread places new requests onto the
 * list, in order of absolute expiration time. The list is
 * protected by a mutex, and the alarm thread sleeps for at
 * least 1 second, each iteration, to ensure that the main
 * thread can lock the mutex to add new work to the list.
 */
#include <pthread.h>
#include <time.h>
#include "errors.h"

/*
 * The "alarm" structure now contains the time_t (time since the
 * Epoch, in seconds) for each alarm, so that they can be
 * sorted. Storing the requested number of seconds would not be
 * enough, since the "alarm thread" cannot tell how long it has
 * been on the list.
 */

typedef enum{
    ALARM_START,
    ALARM_CHANGE,
    ALARM_CANCEL,
    ALARM_SUSPEND,
    ALARM_REACTIVATE,
    ALARM_VIEW,
} alarm_func_t;

typedef struct {
    pthread_t thread_id;
    int alarm_count;
} display_thread_info_t;


typedef struct alarm_tag {
    struct alarm_tag    *link;
    int                 seconds;
    time_t              time;   /* seconds from EPOCH */
    char                message[128];

    int alarm_id;
    alarm_func_t func;
    int status;
    pthread_t assigned_thread;
} alarm_t;

display_thread_info_t display_threads[20];
int display_thread_count = 0;

pthread_mutex_t alarm_mutex = PTHREAD_MUTEX_INITIALIZER;
alarm_t *alarm_list = NULL;

void *display_alarm_thread(void *arg){

    while(1){
        pthread_mutex_lock(&alarm_mutex);

        pthread_mutex_unlock(&alarm_mutex);

        sleep(5);
    }
    return NULL;
}


void *start_alarm_thread(void *arg){
    while(1){
        pthread_mutex_lock(&alarm_mutex);

        alarm_t *alarm = alarm_list;

        while(alarm != NULL){
            if(alarm->func == ALARM_START && alarm->assigned_thread == 0){

                pthread_t chosen_thread = 0;

                for(int i = 0; i < display_thread_count; i++){
                    
                    if(display_threads[i].alarm_count < 2){
                        chosen_thread = display_threads[i].thread_id;
                        display_threads[i].alarm_count++;

                        break;
                    }
                }

                if(chosen_thread == 0){
                    pthread_t new_thread_id;
                    pthread_create(&new_thread_id, NULL, display_alarm_thread, NULL);

                    printf("New Display Alarm Thread %lu Created at %ld\n", new_thread_id, time(NULL));

                    display_threads[display_thread_count].thread_id = new_thread_id;
                    display_threads[display_thread_count].alarm_count = 1;

                    display_thread_count ++;

                    chosen_thread = new_thread_id;
                }

                alarm->assigned_thread = chosen_thread;

                printf("Alarm(%d) Assigned to Display Thread at %ld: %s\n", 
                alarm->alarm_id, time(NULL), alarm->message);

                
            }

            alarm = alarm->link;
            
        }

        pthread_mutex_unlock(&alarm_mutex);
        sleep(1);
    }

    return NULL;
}



/*
 * The alarm thread's start routine.
 */
void *alarm_thread (void *arg)
{
    alarm_t *alarm;
    int sleep_time;
    time_t now;
    int status;

    /*
     * Loop forever, processing commands. The alarm thread will
     * be disintegrated when the process exits.
     */
    while (1) {
        status = pthread_mutex_lock (&alarm_mutex);
        if (status != 0)
            err_abort (status, "Lock mutex");
        alarm = alarm_list;

        /*
         * If the alarm list is empty, wait for one second. This
         * allows the main thread to run, and read another
         * command. If the list is not empty, remove the first
         * item. Compute the number of seconds to wait -- if the
         * result is less than 0 (the time has passed), then set
         * the sleep_time to 0.
         */
        if (alarm == NULL)
            sleep_time = 1;
        else {
            alarm_list = alarm->link;
            now = time (NULL);
            if (alarm->time <= now)
                sleep_time = 0;
            else
                sleep_time = alarm->time - now;
#ifdef DEBUG
            printf ("[waiting: %d(%d)\"%s\"]\n", alarm->time,
                sleep_time, alarm->message);
#endif
            }

        /*
         * Unlock the mutex before waiting, so that the main
         * thread can lock it to insert a new alarm request. If
         * the sleep_time is 0, then call sched_yield, giving
         * the main thread a chance to run if it has been
         * readied by user input, without delaying the message
         * if there's no input.
         */
        status = pthread_mutex_unlock (&alarm_mutex);
        if (status != 0)
            err_abort (status, "Unlock mutex");
        if (sleep_time > 0)
            sleep (sleep_time);
        else
            sched_yield ();

        /*
         * If a timer expired, print the message and free the
         * structure.
         */
        if (alarm != NULL) {
            printf ("(%d) %s\n", alarm->seconds, alarm->message);
            free (alarm);
        }
    }
}

int main (int argc, char *argv[])
{
    int status;
    char line[128];
    alarm_t *alarm, **last, *next;
    pthread_t thread;

    pthread_t start_thread;

    status = pthread_create(&start_thread, NULL, start_alarm_thread, NULL);


    status = pthread_create (
        &thread, NULL, alarm_thread, NULL);
    if (status != 0)
        err_abort (status, "Create alarm thread");
    while (1) {
        printf ("alarm> ");
        if (fgets (line, sizeof (line), stdin) == NULL) exit (0);
        if (strlen (line) <= 1) continue;
        alarm = (alarm_t*)malloc (sizeof (alarm_t));
        if (alarm == NULL)
            errno_abort ("Allocate alarm");

        /*
         * Parse input line into seconds (%d) and a message
         * (%64[^\n]), consisting of up to 64 characters
         * separated from the seconds by whitespace.
         */


        if(sscanf(line, "Start_Alarm(%d): %d %[^\n]", 
        &alarm->alarm_id, &alarm->seconds, alarm->message) == 3){
            alarm->func = ALARM_START;
            printf("Start_Alarm(%d) Request Inserted Into Alarm List: %ld %d %s\n",
       alarm->alarm_id, time(NULL), alarm->seconds, alarm->message);

        } else if(sscanf(line, "Change_Alarm(%d): %d %[^\n]",
        &alarm->alarm_id, &alarm->seconds, alarm->message) == 3){
            alarm->func = ALARM_CHANGE;

        } else if (sscanf(line, "Cancel_Alarm(%d)", &alarm->alarm_id) == 1){
            alarm->func = ALARM_CANCEL;

        } else if(sscanf(line, "Suspend_Alarm(%d)", &alarm->alarm_id) == 1){
            alarm->func = ALARM_SUSPEND;

        } else if (sscanf(line, "Reactivate_Alarm(%d)", &alarm->alarm_id) == 1){
            alarm->func = ALARM_REACTIVATE;

        } else if(sscanf(line, "View_Alarms", 10) == 0){
            alarm->func = ALARM_VIEW;

        } else{
            fprintf(stderr, "Bad command\n");
            free(alarm);
            continue;
        }
        

            status = pthread_mutex_lock (&alarm_mutex);
            if (status != 0)
                err_abort (status, "Lock mutex");
            alarm->time = time (NULL) + alarm->seconds;

            /*
             * Insert the new alarm into the list of alarms,
             * sorted by expiration time.
             */
            last = &alarm_list;
            next = *last;
            while (next != NULL) {
                if (next->time >= alarm->time) {
                    alarm->link = next;
                    *last = alarm;
                    break;
                }
                last = &next->link;
                next = next->link;
            }
            /*
             * If we reached the end of the list, insert the new
             * alarm there. ("next" is NULL, and "last" points
             * to the link field of the last item, or to the
             * list header).
             */
            if (next == NULL) {
                *last = alarm;
                alarm->link = NULL;
            }
#ifdef DEBUG
            printf ("[list: ");
            for (next = alarm_list; next != NULL; next = next->link)
                printf ("%d(%d)[\"%s\"] ", next->time,
                    next->time - time (NULL), next->message);
            printf ("]\n");
#endif
            status = pthread_mutex_unlock (&alarm_mutex);
            if (status != 0)
                err_abort (status, "Unlock mutex");
        }
    // }
}
